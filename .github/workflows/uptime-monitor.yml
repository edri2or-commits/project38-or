name: Uptime Monitor

on:
  schedule:
    # Run every 5 minutes
    - cron: '*/5 * * * *'
  workflow_dispatch:  # Manual trigger

permissions:
  contents: read
  issues: write  # For creating issues on failures

concurrency:
  group: uptime-monitor
  cancel-in-progress: false

jobs:
  health-check:
    name: Production Health Check
    runs-on: ubuntu-latest

    outputs:
      health_status: ${{ steps.check.outputs.status }}
      response_time: ${{ steps.check.outputs.response_time }}

    steps:
      - name: Check Production Health
        id: check
        env:
          PRODUCTION_URL: ${{ vars.RAILWAY_URL || 'https://or-infra.com' }}
        run: |
          echo "üè• Checking health at $PRODUCTION_URL/api/health"

          # Measure response time
          START_TIME=$(date +%s%N)

          # Make health check request
          HTTP_CODE=$(curl -s -o response.json -w "%{http_code}" \
            --connect-timeout 10 \
            --max-time 30 \
            "$PRODUCTION_URL/api/health" || echo "000")

          END_TIME=$(date +%s%N)
          RESPONSE_TIME=$(( (END_TIME - START_TIME) / 1000000 ))

          echo "response_time=$RESPONSE_TIME" >> $GITHUB_OUTPUT

          if [ "$HTTP_CODE" = "200" ]; then
            echo "status=healthy" >> $GITHUB_OUTPUT
            echo "‚úÖ Health check passed (${RESPONSE_TIME}ms)"
            cat response.json | jq '.'
          else
            echo "status=unhealthy" >> $GITHUB_OUTPUT
            echo "‚ùå Health check failed: HTTP $HTTP_CODE (${RESPONSE_TIME}ms)"
            cat response.json 2>/dev/null || echo "No response body"
          fi

      - name: Check Additional Endpoints
        if: steps.check.outputs.status == 'healthy'
        env:
          PRODUCTION_URL: ${{ vars.RAILWAY_URL || 'https://or-infra.com' }}
        run: |
          echo "üìä Checking additional endpoints..."

          # Check metrics endpoint
          METRICS_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 5 \
            --max-time 10 \
            "$PRODUCTION_URL/metrics/summary" || echo "000")
          echo "Metrics endpoint: HTTP $METRICS_CODE"

          # Check docs endpoint
          DOCS_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 5 \
            --max-time 10 \
            "$PRODUCTION_URL/docs" || echo "000")
          echo "Docs endpoint: HTTP $DOCS_CODE"

          # Check agents endpoint
          AGENTS_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
            --connect-timeout 5 \
            --max-time 10 \
            "$PRODUCTION_URL/api/agents" || echo "000")
          echo "Agents endpoint: HTTP $AGENTS_CODE"

  alert-on-failure:
    name: Alert on Failure
    runs-on: ubuntu-latest
    needs: health-check
    if: needs.health-check.outputs.health_status == 'unhealthy'

    steps:
      - name: Check for Existing Issue
        id: check_issue
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'production,outage',
              per_page: 1
            });

            if (issues.length > 0) {
              core.setOutput('exists', 'true');
              core.setOutput('issue_number', issues[0].number);
            } else {
              core.setOutput('exists', 'false');
            }

      - name: Create Outage Issue
        if: steps.check_issue.outputs.exists == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const responseTime = '${{ needs.health-check.outputs.response_time }}';
            const timestamp = new Date().toISOString();

            const body = `## üö® Production Outage Detected

            **Detected at:** ${timestamp}
            **Response time:** ${responseTime}ms
            **Status:** Unhealthy

            ### Details
            - Health endpoint returned non-200 status
            - Automatic monitoring detected the issue

            ### Actions Required
            1. Check Railway dashboard for deployment status
            2. Review recent deployments for issues
            3. Check database connectivity
            4. Review application logs

            ### Quick Links
            - [Railway Dashboard](https://railway.app/project/95ec21cc-9ada-41c5-8485-12f9a00e0116)
            - [Recent Deployments](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/workflows/deploy-railway.yml)

            ---
            *This issue was automatically created by the Uptime Monitor workflow.*
            `;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: 'üö® Production Outage Detected',
              body: body,
              labels: ['production', 'outage', 'urgent']
            });

      - name: Update Existing Issue
        if: steps.check_issue.outputs.exists == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const timestamp = new Date().toISOString();
            const issueNumber = ${{ steps.check_issue.outputs.issue_number }};

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: `‚ö†Ô∏è Health check still failing at ${timestamp}`
            });

  close-resolved-issues:
    name: Close Resolved Issues
    runs-on: ubuntu-latest
    needs: health-check
    if: needs.health-check.outputs.health_status == 'healthy'

    steps:
      - name: Find and Close Outage Issues
        uses: actions/github-script@v7
        with:
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'production,outage',
            });

            for (const issue of issues) {
              const timestamp = new Date().toISOString();

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: `‚úÖ **Resolved** at ${timestamp}\n\nHealth check is now passing. Closing this issue.`
              });

              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                state: 'closed',
                state_reason: 'completed'
              });

              console.log(`Closed issue #${issue.number}`);
            }

  record-metrics:
    name: Record Metrics
    runs-on: ubuntu-latest
    needs: health-check
    if: always()

    steps:
      - name: Log Metrics
        run: |
          echo "## Uptime Monitor Metrics"
          echo ""
          echo "| Metric | Value |"
          echo "|--------|-------|"
          echo "| Status | ${{ needs.health-check.outputs.health_status }} |"
          echo "| Response Time | ${{ needs.health-check.outputs.response_time }}ms |"
          echo "| Timestamp | $(date -u +%Y-%m-%dT%H:%M:%SZ) |"
          echo "| Workflow Run | ${{ github.run_id }} |"
