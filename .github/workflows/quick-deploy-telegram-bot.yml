name: Quick Deploy Telegram Bot

on:
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  RAILWAY_PROJECT_ID: "95ec21cc-9ada-41c5-8485-12f9a00e0116"
  RAILWAY_ENVIRONMENT_ID: "99c99a18-aea2-4d01-9360-6a93705102a0"

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: 'projects/979429709900/locations/global/workloadIdentityPools/github-pool/providers/github-provider'
          service_account: 'claude-code-agent@project38-483612.iam.gserviceaccount.com'

      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Get Secrets
        id: secrets
        run: |
          RAILWAY_TOKEN=$(gcloud secrets versions access latest --secret="RAILWAY-API" --project=project38-483612)
          BOT_TOKEN=$(gcloud secrets versions access latest --secret="TELEGRAM-BOT-TOKEN" --project=project38-483612)
          echo "::add-mask::$RAILWAY_TOKEN"
          echo "::add-mask::$BOT_TOKEN"
          echo "railway_token=$RAILWAY_TOKEN" >> $GITHUB_OUTPUT
          echo "bot_token=$BOT_TOKEN" >> $GITHUB_OUTPUT

      - name: Find or Create Telegram Bot Service
        id: service
        env:
          RAILWAY_TOKEN: ${{ steps.secrets.outputs.railway_token }}
        run: |
          # Find existing telegram-bot service
          SERVICES=$(curl -s -X POST \
            "https://backboard.railway.app/graphql/v2" \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "query": "query { project(id: \"'"$RAILWAY_PROJECT_ID"'\") { services { edges { node { id name } } } } }"
            }')

          echo "Services response:"
          echo "$SERVICES" | jq '.data.project.services.edges[].node'

          SERVICE_ID=$(echo "$SERVICES" | jq -r '.data.project.services.edges[] | select(.node.name == "telegram-bot") | .node.id' | head -1)

          if [ -z "$SERVICE_ID" ] || [ "$SERVICE_ID" = "null" ]; then
            echo "Creating new telegram-bot service..."
            CREATE=$(curl -s -X POST \
              "https://backboard.railway.app/graphql/v2" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{
                "query": "mutation { serviceCreate(input: { name: \"telegram-bot\", projectId: \"'"$RAILWAY_PROJECT_ID"'\" }) { id name } }"
              }')
            echo "Create response: $CREATE"
            SERVICE_ID=$(echo "$CREATE" | jq -r '.data.serviceCreate.id')
          fi

          echo "Service ID: $SERVICE_ID"
          echo "service_id=$SERVICE_ID" >> $GITHUB_OUTPUT

      - name: Check Service Status
        id: status
        env:
          RAILWAY_TOKEN: ${{ steps.secrets.outputs.railway_token }}
          SERVICE_ID: ${{ steps.service.outputs.service_id }}
        run: |
          echo "Checking service $SERVICE_ID status..."

          STATUS=$(curl -s -X POST \
            "https://backboard.railway.app/graphql/v2" \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "query": "query { service(id: \"'"$SERVICE_ID"'\") { name updatedAt deployments(first: 3) { edges { node { id status createdAt } } } serviceInstances { edges { node { id domains { serviceDomains { domain } } } } } } }"
            }')

          echo "Service status:"
          echo "$STATUS" | jq '.'

          DOMAIN=$(echo "$STATUS" | jq -r '.data.service.serviceInstances.edges[0].node.domains.serviceDomains[0].domain // "no domain"')
          DEPLOY_STATUS=$(echo "$STATUS" | jq -r '.data.service.deployments.edges[0].node.status // "no deployment"')

          echo "Domain: $DOMAIN"
          echo "Latest deployment status: $DEPLOY_STATUS"
          echo "domain=$DOMAIN" >> $GITHUB_OUTPUT

      - name: Configure Service and Deploy
        id: deploy
        env:
          RAILWAY_TOKEN: ${{ steps.secrets.outputs.railway_token }}
          SERVICE_ID: ${{ steps.service.outputs.service_id }}
          BOT_TOKEN: ${{ steps.secrets.outputs.bot_token }}
        run: |
          echo "=== Setting environment variables ==="

          # Set all required env vars
          for VAR_NAME in "TELEGRAM_BOT_TOKEN:$BOT_TOKEN" "LITELLM_GATEWAY_URL:https://litellm-gateway-production-0339.up.railway.app" "GCP_PROJECT_ID:project38-483612" "PORT:8000"; do
            NAME=$(echo $VAR_NAME | cut -d: -f1)
            VALUE=$(echo $VAR_NAME | cut -d: -f2-)
            RESULT=$(curl -s -X POST "https://backboard.railway.app/graphql/v2" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"query": "mutation { variableUpsert(input: { projectId: \"'"$RAILWAY_PROJECT_ID"'\", environmentId: \"'"$RAILWAY_ENVIRONMENT_ID"'\", serviceId: \"'"$SERVICE_ID"'\", name: \"'"$NAME"'\", value: \"'"$VALUE"'\" }) }"}')
            echo "Set $NAME: $(echo $RESULT | jq -r '.errors // "✅"')"
          done

          echo ""
          echo "=== Connecting to GitHub repo ==="
          CONNECT=$(curl -s -X POST "https://backboard.railway.app/graphql/v2" \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "query": "mutation { serviceConnect(id: \"'"$SERVICE_ID"'\", input: { repo: \"edri2or-commits/project38-or\", branch: \"main\" }) { id } }"
            }')

          CONNECT_ERROR=$(echo "$CONNECT" | jq -r '.errors[0].message // empty')
          if [ -n "$CONNECT_ERROR" ]; then
            echo "⚠️ Connect error (may already be connected): $CONNECT_ERROR"
          else
            echo "✅ Connected to GitHub repo"
          fi

          echo ""
          echo "=== Setting root directory ==="
          ROOT=$(curl -s -X POST "https://backboard.railway.app/graphql/v2" \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{
              "query": "mutation { serviceUpdate(id: \"'"$SERVICE_ID"'\", input: { rootDirectory: \"services/telegram-bot\" }) { id rootDirectory } }"
            }')
          echo "Root directory set: $(echo $ROOT | jq -r '.data.serviceUpdate.rootDirectory // .errors')"

          echo ""
          echo "=== Triggering deployment ==="
          # Use deploymentTrigger which works for new deployments
          DEPLOY=$(curl -s -X POST "https://backboard.railway.app/graphql/v2" \
            -H "Authorization: Bearer $RAILWAY_TOKEN" \
            -H "Content-Type: application/json" \
            -d '{"query": "mutation { deploymentTrigger(input: { serviceId: \"'"$SERVICE_ID"'\", environmentId: \"'"$RAILWAY_ENVIRONMENT_ID"'\" }) { id status } }"}')

          DEPLOY_ERROR=$(echo "$DEPLOY" | jq -r '.errors[0].message // empty')
          DEPLOY_ID=$(echo "$DEPLOY" | jq -r '.data.deploymentTrigger.id // empty')
          DEPLOY_STATUS=$(echo "$DEPLOY" | jq -r '.data.deploymentTrigger.status // empty')

          if [ -n "$DEPLOY_ERROR" ]; then
            echo "⚠️ Deployment trigger error: $DEPLOY_ERROR"
            # Try serviceInstanceRedeploy as fallback
            echo "Trying serviceInstanceRedeploy as fallback..."
            DEPLOY=$(curl -s -X POST "https://backboard.railway.app/graphql/v2" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"query": "mutation { serviceInstanceRedeploy(environmentId: \"'"$RAILWAY_ENVIRONMENT_ID"'\", serviceId: \"'"$SERVICE_ID"'\") }"}')
            echo "Redeploy response: $DEPLOY"
          else
            echo "✅ Deployment triggered: $DEPLOY_ID (status: $DEPLOY_STATUS)"
          fi

          echo ""
          echo "=== Waiting for deployment (60s) ==="
          sleep 60

          echo ""
          echo "=== Checking deployment status ==="
          for i in 1 2 3 4 5; do
            STATUS=$(curl -s -X POST "https://backboard.railway.app/graphql/v2" \
              -H "Authorization: Bearer $RAILWAY_TOKEN" \
              -H "Content-Type: application/json" \
              -d '{"query": "query { service(id: \"'"$SERVICE_ID"'\") { name repo { fullRepoName } rootDirectory deployments(first: 1) { edges { node { id status createdAt } } } serviceInstances { edges { node { domains { serviceDomains { domain } } } } } } }"}')

            DEPLOY_STATUS=$(echo "$STATUS" | jq -r '.data.service.deployments.edges[0].node.status // "unknown"')
            DOMAIN=$(echo "$STATUS" | jq -r '.data.service.serviceInstances.edges[0].node.domains.serviceDomains[0].domain // "no domain"')
            REPO=$(echo "$STATUS" | jq -r '.data.service.repo.fullRepoName // "not connected"')
            ROOT_DIR=$(echo "$STATUS" | jq -r '.data.service.rootDirectory // "/"')

            echo "Check $i: status=$DEPLOY_STATUS, domain=$DOMAIN, repo=$REPO, root=$ROOT_DIR"

            if [ "$DEPLOY_STATUS" = "SUCCESS" ]; then
              echo ""
              echo "✅ Deployment successful!"
              echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
              echo "status=success" >> $GITHUB_OUTPUT
              break
            elif [ "$DEPLOY_STATUS" = "FAILED" ] || [ "$DEPLOY_STATUS" = "CRASHED" ]; then
              echo ""
              echo "❌ Deployment failed with status: $DEPLOY_STATUS"
              echo "status=failed" >> $GITHUB_OUTPUT
              exit 1
            fi

            if [ $i -lt 5 ]; then
              echo "Waiting 30s for deployment..."
              sleep 30
            fi
          done

          if [ "$DEPLOY_STATUS" != "SUCCESS" ]; then
            echo ""
            echo "⚠️ Deployment still in progress: $DEPLOY_STATUS"
            echo "domain=$DOMAIN" >> $GITHUB_OUTPUT
            echo "status=$DEPLOY_STATUS" >> $GITHUB_OUTPUT
          fi

      - name: Test Webhook Endpoint
        if: steps.deploy.outputs.domain != 'no domain'
        env:
          DOMAIN: ${{ steps.deploy.outputs.domain }}
        run: |
          echo "Testing webhook endpoint..."
          HEALTH=$(curl -s --max-time 10 "https://$DOMAIN/health" || echo "error")
          echo "Health check: $HEALTH"

          ROOT=$(curl -s --max-time 10 "https://$DOMAIN/" || echo "error")
          echo "Root endpoint: $ROOT"
